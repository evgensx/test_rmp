Задание 1.1:
Есть 2 таблицы Table_A, Table_B

Структура таблиц
Table_A:

Id (int), Name (string)

Table_B:
Id (int), Name (string), Id_A (int)

Id_A - внешний ключ на запись в таблице Table_A

Вопросы:
Сколько записей вернет запрос следующий запрос?
select * from Table_A inner join Table_B

Ответ: произведение количества записей Table_A и Table_B

---------------------------

Сколько записей вернет следующий запрос?
select * from Table_A a inner join Table_B b on a.ID=b.Id_A

Ответ: количество записей где поле id из Table_A равно значению поля Id_A из таблицы Table_B

------------------------

чем отличаются следующие запросы?
select * from Table_A a inner join Table_B b on a.ID=b.Id_A
select * from Table_A a left join Table_B b on a.ID=b.Id_A

Ответ: при inner join выводятся только записи из обеих таблиц, где совпадают поля a.ID и b.Id_A. При left join к совпадающим записям добавляются оставшиеся записи из Table_А, а поля из таблицы Table_B выводятся как пустые (null)

--------------------

Задание 1.2:

Есть таблица transactions в таком вид
+-----------+------------+
| date      | cash_flow  |
+-----------+------------+
|2022-01-01 |-1000       |
+-----------+------------+
|2022-01-02 |-520        |
+-----------+------------+
|2022-01-04 |80          |
+-----------+------------+


Где cash_flow — это выручка минус затраты за каждый день.

Нужно написать запрос, чтобы получить нарастающий итог для денежного потока каждый день таким образом, чтобы в конечном итоге получилась таблица в такой форме:

+-----------+------------+------------+
| date      | cash_flow  |  cum_cf    |
+-----------+------------+------------+
|2022-01-01 |-1000       |-1000       |
+-----------+------------+------------+
|2022-01-02 |-520        |-1520       |
+-----------+------------+------------+
|2022-01-04 |80          |-1440       |
+-----------+------------+------------+

Ответ: 
SELECT 
date, 
cash_flow, 
SUM(cash_flow) OVER(ORDER by date) cum_cf 
FROM transactions

--------------------

Задание 1.3:
Дан массив объектов с полями id (уникальный идентификатор) и parentId (идентификатор родителя). Для входных данных верно следующее: индекс дочерней записи всегда больше индекса родительской в исходном массиве.
Задача: превратить массив "плоских" объектов в массив объектов с вложенными детьми (поле children).

Пример исходных данных:
[{
  id: 1,
  parentId: 0
}, {
  id: 2,
  parentId: 0
}, {
  id: 3,
  parentId: 1
}, {
  id: 4,
  parentId: 1
}, {
  id: 5,
  parentId: 2
}, {
  id: 6,
  parentId: 4
}, {
  id: 7,
  parentId: 5
}];

Ожидаемый результат:

  [{
    "id": 1,
    "parentId": 0,
    "children": [{
      "id": 3,
      "parentId": 1
    }, {
      "id": 4,
      "parentId": 1,
      "children": [{
        "id": 6,
        "parentId": 4
      }]
    }]
  }, {
    "id": 2,
    "parentId": 0,
    "children": [{
      "id": 5,
      "parentId": 2,
      "children": [{
        "id": 7,
        "parentId": 5
      }]
    }]
  }]



Решение:

menu = [
    {"id": 1, "parentId": 0},
    {"id": 2, "parentId": 0},
    {"id": 3, "parentId": 1},
    {"id": 4, "parentId": 1},
    {"id": 5, "parentId": 2},
    {"id": 6, "parentId": 4},
    {"id": 7, "parentId": 5},
]


pid_list = [x["parentId"] for x in menu]

for i in menu:
    if i["id"] in pid_list:
        i["children"] = []

result = []

for i in menu:
    pid = i["parentId"]
    if pid == 0:
        result.append(i)
    else:
        parent = menu[pid - 1]
        parent["children"].append(i)

print(result)

----------------------

Задание 1.4:
Опишите процесс проектирования аналога Telegram:
- стек технологий
- используемые СУБД
- архитектура интерфейсной и серверной части (в виде схем, диаграмм) с описанием взаимодействия модулей.

Ответ:
Зная python
Микросервисная инфраструктура

1. Фронтенд: веб vuejs,
			остальное бы сделал на flutter
2. Бэкэнд: фреймворк Django + DRF, сервер Nginx

3. Развертывание: Docker для контейнеризации, VPS на Ubuntu

4. Базы данных: Postgres для хранения данных, сообщений, аккаутов. Reddis для кэширования однотипных запросов. Моngo для хранения метрик, архивов сообщений, логов

6. Сервис очередей: RabbitMqtt для управления нагрузкой сообщений на базы данных

6. Мониторинг: Отправка ошибок на почту. Сбор метрик Grafana + Prometheus 

7. Коммуникация: Rest API, JSON, хотя уже есть более быстрый grpc, Вебсокеты

8. Система безопасности: JWT для авторизации и TLS  для шифрования сообщений
